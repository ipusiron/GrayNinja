<!--
---
title: GrayNinja
category: code-visualization
difficulty: 2
description: Visual tool for understanding Gray (Reflected Binary) code via conversions and encoder disk visualization.
tags: [gray-code, binary, visualization, code, security, education]
demo: https://ipusiron.github.io/GrayNinja/
---
-->

![GitHub Repo stars](https://img.shields.io/github/stars/ipusiron/GrayNinja?style=social)
![GitHub forks](https://img.shields.io/github/forks/ipusiron/GrayNinja?style=social)
![GitHub last commit](https://img.shields.io/github/last-commit/ipusiron/GrayNinja)
![GitHub license](https://img.shields.io/github/license/ipusiron/GrayNinja)
[![GitHub Pages](https://img.shields.io/badge/demo-GitHub%20Pages-blue?logo=github)](https://ipusiron.github.io/GrayNinja/)


**Day066 - 生成AIで作るセキュリティツール100**

# GrayNinja - グレイコードのエンコーダー・ディスク可視化ツール

**GrayNinja**は、Gray Code（グレイコード・反射バイナリコード）を直感的に理解するためのインタラクティブ学習ツールです。

- **基本概念の理解**: Binary/Gray変換の仕組みと隣接1ビット差の性質
- **視覚的体験**: エンコーダー・ディスクによる回転角度とコード変化の関係
- **実践的変換**: 任意のビット列の相互変換とアルゴリズム確認
- **応用事例**: 通信・制御・セキュリティ分野での実用例紹介

---

## 🌐 デモページ

👉 **[https://ipusiron.github.io/GrayNinja/](https://ipusiron.github.io/GrayNinja/)**

ブラウザーで直接お試しいただけます。

---

## 📸 スクリーンショット

>![エンコーダー・ディスクの回転アニメーション](assets/screenshot.png)
>*エンコーダー・ディスクの回転アニメーション*

---

## 🎯 ターゲットユーザー

本ツールは以下のような方々に最適です：

### 学習者・学生
- **情報工学・電子工学専攻の学生**: デジタル回路、情報理論の授業補完
- **プログラミング学習者**: ビット操作とアルゴリズムの理解促進
- **資格試験受験者**: 基本情報技術者試験、応用情報技術者試験対策

### 技術者・エンジニア
- **組み込み系エンジニア**: エンコーダー・センサー設計の実装理解
- **通信系エンジニア**: QAM/PSK変調におけるGrayラベリングの効果確認
- **セキュリティエンジニア**: サイドチャネル攻撃対策の理論的背景学習
- **FPGA/ASIC設計者**: 状態遷移最適化と論理回路設計への応用

### 教育関係者
- **情報系教員**: 視覚的教材としての授業活用
- **研修講師**: 企業研修での実践的説明ツール
- **技術書執筆者**: Gray Codeの概念説明における参考資料

### 研究者・上級者
- **アルゴリズム研究者**: ハミルトン路問題、組合せ最適化の教材
- **暗号研究者**: ハードウェアセキュリティの実装技術研究

---

## 📚 背景と理論

### 2進数コードの種類と比較

デジタルシステムでは、10進数を2進数で表現する際に様々なコード体系が使用されます。それぞれ異なる特性と用途を持ち、適用場面によって使い分けられています。

#### 主要な2進数コードの比較表

| 10進数 | バイナリ（Binary） | グレイ（Gray） | BCD（8421） | ハミング距離<br>（前の値から） |
|--------|------------------|----------------|-------------|------------------------------|
| 0      | 0000             | 0000          | 0000        | Binary: - / Gray: - / BCD: - |
| 1      | 0001             | 0001          | 0001        | Binary: 1 / Gray: **1** / BCD: 1 |
| 2      | 0010             | 0011          | 0010        | Binary: 2 / Gray: **1** / BCD: 2 |
| 3      | 0011             | 0010          | 0011        | Binary: 1 / Gray: **1** / BCD: 1 |
| 4      | 0100             | 0110          | 0100        | Binary: 3 / Gray: **1** / BCD: 3 |
| 5      | 0101             | 0111          | 0101        | Binary: 1 / Gray: **1** / BCD: 1 |
| 6      | 0110             | 0101          | 0110        | Binary: 2 / Gray: **1** / BCD: 2 |
| 7      | 0111             | 0100          | 0111        | Binary: 1 / Gray: **1** / BCD: 1 |
| 8      | 1000             | 1100          | 1000        | Binary: **4** / Gray: **1** / BCD: **4** |
| 9      | 1001             | 1101          | 1001        | Binary: 1 / Gray: **1** / BCD: 1 |
| 10     | 1010             | 1111          | 0001 0000   | Binary: 2 / Gray: **1** / BCD: - |
| 11     | 1011             | 1110          | 0001 0001   | Binary: 1 / Gray: **1** / BCD: - |
| 12     | 1100             | 1010          | 0001 0010   | Binary: 3 / Gray: **1** / BCD: - |
| 13     | 1101             | 1011          | 0001 0011   | Binary: 1 / Gray: **1** / BCD: - |
| 14     | 1110             | 1001          | 0001 0100   | Binary: 2 / Gray: **1** / BCD: - |
| 15     | 1111             | 1000          | 0001 0101   | Binary: 1 / Gray: **1** / BCD: - |

**※ 太字はGray Codeの特徴である「常にハミング距離1」を示す**

#### 各コードの特徴と応用

1. **バイナリコード（Binary Code）**
   - **特徴**: 最も一般的な2進数表現、演算効率が高い
   - **問題点**: 値変化時に複数ビットが同時変化（例：7→8で4ビット変化）
   - **用途**: コンピューター内部演算、メモリアドレス、一般的なデジタル処理
   - **利点**: 数値計算、論理演算に最適化

2. **グレイコード（Gray Code）** ★本ツールの主要テーマ
   - **特徴**: 隣接する値で必ず1ビットのみが変化、反射対称性
   - **利点**: 読み取りエラー最小化、ノイズ耐性、サイドチャネル攻撃対策
   - **用途**: エンコーダー、ADC、通信変調、セキュリティ実装
   - **重要性**: ハードウェア設計、エラー訂正において極めて重要

3. **BCDコード（Binary Coded Decimal）**
   - **特徴**: 10進数の各桁を4ビットで独立表現
   - **制約**: 1010-1111（10-15）は使用不可、冗長性あり
   - **用途**: 電卓、デジタル時計、金融計算システム
   - **利点**: 10進演算の簡素化、表示変換の効率化

#### コード選択の指針

| 要件 | 推奨コード | 理由 |
|------|------------|------|
| 高速演算処理 | **Binary** | 直接的な算術演算に最適 |
| エラー最小化 | **Gray** | 1ビット変化によるノイズ耐性 |
| 10進表示 | **BCD** | 桁ごとの独立処理が容易 |
| セキュリティ | **Gray** | 電力解析攻撃への耐性 |
| 位置検出 | **Gray** | エンコーダーでの読み取り安定性 |
| 通信変調 | **Gray** | 隣接シンボル誤りの影響最小化 |

### ハミング距離とは

**ハミング距離**は、情報理論における基本的な概念で、**同じ長さの2つの文字列で異なる位置の個数**を表します。この概念は、エラー検出・訂正、通信システム、暗号学など幅広い分野で活用されています。

#### 基本的な計算方法

1. **2つの同じ長さのビット列を比較**
2. **各位置で異なるビットの個数を数える**
3. **その合計がハミング距離**

#### 計算例

```
文字列A: 1010
文字列B: 1100
         ↓↓
比較:    10xx  (位置2と位置3が異なる)
ハミング距離: 2
```

#### Gray Codeでの重要性

Gray Codeの最も重要な特徴は、**隣接する値のハミング距離が常に1**であることです：

```
値  | Binary | Gray | 前の値との距離
0   | 0000   | 0000 | -
1   | 0001   | 0001 | 1 (0000→0001)
2   | 0010   | 0011 | 1 (0001→0011)
3   | 0011   | 0010 | 1 (0011→0010)
4   | 0100   | 0110 | 1 (0010→0110)
```

一方、通常のBinaryコードでは複数ビットが同時に変化することがあります：

```
値7: 0111 → 値8: 1000 (ハミング距離: 4)
```

この「1ビットのみの変化」という性質が、エンコーダーの読み取りエラー防止、通信システムの誤り最小化、セキュリティシステムでの攻撃耐性向上などに活用されています。

### Gray コードの基本性質とセキュリティ応用

Gray code（グレイコード・反射バイナリコード）は、**連続する値で1ビットだけ変化する**特殊なバイナリコードです。
この性質により、**エラー抑制**・**安定した読み取り**・**論理簡略化**・**セキュリティ向上**など多くの場面で役立ちます。

特に、暗号・セキュリティ分野では以下の重要な特性があります：
- **電力消費の一様化**: 隣接値間で変化するビット数が常に1のため、電力解析攻撃を困難にする
- **ハミング重み変化の最小化**: ビット変化パターンが予測困難になり、サイドチャネル攻撃の成功率を低下させる
- **状態遷移の安定性**: セキュリティクリティカルなシステムでの確実な状態判定を実現

#### 1. 隣接1ビット差の性質
- 連続する値間で必ず1ビットのみが変化
- 巡回性（closed cycle）：最大値から0に戻る際も1ビット差
- 対称性：コード列が左右対称の構造を持つ

#### 2. 生成の仕組み
Gray コードは「対称的な折り返し」によって生成されます：
- 初期コード（0, 1）から開始
- 各段階で前の段階のコードを逆順に配置
- 新しい桁を先頭に追加して拡張

#### 3. 数学的特徴
- **対称性**: ビット変化パターンが高度に対称
- **連続性**: 実数表現における連続性を保持
- **一意性**: 一部の数値が複数の表現を持つ柔軟な符号化

### バイナリ ⇔ グレイコード相互変換

#### Binary → Gray 変換

**変換式**: `g = b ⊕ (b >> 1)`

**手順**:
1. バイナリコードの最上位ビットはそのままグレイコードの最上位ビットになる
2. 他のビットは、バイナリコードとその1ビット右シフトのXORで求める

**例**: バイナリ `1010` → グレイ `1111`
```
バイナリ:     1 0 1 0
右シフト:     0 1 0 1
XOR結果:      1 1 1 1  ← グレイコード
```

**ビット毎の計算**:
- g₃ = b₃ = 1
- g₂ = b₃ ⊕ b₂ = 1 ⊕ 0 = 1
- g₁ = b₂ ⊕ b₁ = 0 ⊕ 1 = 1
- g₀ = b₁ ⊕ b₀ = 1 ⊕ 0 = 1

#### Gray → Binary 変換

**変換式**: `bₙ = gₙ, bᵢ = bᵢ₊₁ ⊕ gᵢ`

**手順**:
1. グレイコードの最上位ビットはそのままバイナリコードの最上位ビットになる
2. 他のビットは、直前に求めたバイナリビットとグレイビットのXORで求める

**例**: グレイ `1111` → バイナリ `1010`
```
グレイ:       1 1 1 1
```

**ビット毎の計算**:
- b₃ = g₃ = 1
- b₂ = b₃ ⊕ g₂ = 1 ⊕ 1 = 0
- b₁ = b₂ ⊕ g₁ = 0 ⊕ 1 = 1
- b₀ = b₁ ⊕ g₀ = 1 ⊕ 1 = 0

**結果**: バイナリ `1010`

#### 本ツールでの変換例（実装済み機能）

**Binary → Gray変換例**: 入力`1010` → 出力`1111`
```
ステップ1: 最上位ビット
g₃ = b₃ = 1

ステップ2: ビット2
g₂ = b₃ ⊕ b₂ = 1 ⊕ 0 = 1

ステップ3: ビット1
g₁ = b₂ ⊕ b₁ = 0 ⊕ 1 = 1

ステップ4: ビット0
g₀ = b₁ ⊕ b₀ = 1 ⊕ 0 = 1

結果: 1010 → 1111
```

**Gray → Binary変換例**: 入力`1111` → 出力`1010`
```
ステップ1: 最上位ビット
b₃ = g₃ = 1

ステップ2: ビット2
b₂ = b₃ ⊕ g₂ = 1 ⊕ 1 = 0

ステップ3: ビット1
b₁ = b₂ ⊕ g₁ = 0 ⊕ 1 = 1

ステップ4: ビット0
b₀ = b₁ ⊕ g₀ = 1 ⊕ 1 = 0

結果: 1111 → 1010
```

※ 本ツールの変換タブでこれらの計算過程を実際に確認できます

### Gray コードの種類

Gray コードには目的や用途に応じて複数の種類が存在します。本ツールでは最も一般的な「**バイナリ反射グレイコード**」を扱っていますが、他にも以下のような種類があります：

#### 1. バイナリ反射グレイコード（Binary Reflected Gray Code / BRGC）
- **特徴**: 連続する値の間で1ビットのみが変化
- **用途**: デジタルエンコーダー、本ツールの対象
- **利点**: データ送信と解釈のエラーを最小限に抑制

#### 2. バランスド・グレイコード（Balanced Gray Code）
- **特徴**: 各値が均一な遷移で正確に1回表示
- **用途**: アナログ-デジタル変換器
- **利点**: 高精度の電子測定に効果的

#### 3. N-Aryグレイコード（Non-Binary Gray Code）
- **特徴**: 0、1以外の値（2、3など）も含む多進グレイコード
- **用途**: 複雑なエンコードシナリオ
- **利点**: マルチステートシステムに適用可能

#### 4. 二次元グレイコード（2D Gray Code）
- **特徴**: 2次元配列のデータを管理
- **用途**: 画像処理、高度なデータ送信技術
- **利点**: エラー修正に特に有効

*本ツールで学習する標準的なグレイコードは「バイナリ反射グレイコード」です。*

---

## 🔢 Gray コードのアルゴリズム

### 変換アルゴリズム

#### Binary → Gray 変換
```
G = B ⊕ (B >> 1)
```
- 元のバイナリコードを右シフト
- 元のコードとXOR演算

#### Gray → Binary 変換
```
累積XOR（MSBから順次）
B₀ = G₀
Bᵢ = Bᵢ₋₁ ⊕ Gᵢ
```

### 再帰的生成アルゴリズム（反射バイナリコード）

#### 基本原理
1. **G(1) = [0, 1]** （初期値）
2. **G(n) = [0 + G(n−1)] + [1 + reverse(G(n−1))]**
3. **例**: G(2) = [00, 01] + [11, 10] = [00, 01, 11, 10]

#### ステップバイステップ例（n=3）
```
G(1) = [0, 1]
G(2) = [00, 01] + [11, 10]
G(3) = [000, 001, 011, 010] + [110, 111, 101, 100]
     = [000, 001, 011, 010, 110, 111, 101, 100]
```

### Gray コードの深い理論

#### 1. センサー応用の数学的根拠
- **遷移エラー防止**: 値変化時に複数ビットが同時変化しない
- **ノイズ耐性**: 1ビットエラーでも隣接値にのみ影響
- **読み取り安定性**: アナログ・デジタル変換時の安定性向上

#### 2. カオス理論との関連
- **テント関数**: Gray コードの無限ビット列は実数のテント関数写像と対応
- **フラクタル構造**: 自己相似性を持つ階層構造
- **連続性**: 実数表現における左右計算の柔軟性

#### 3. 組合せ論的性質
- **ハミルトン路**: n次元ハイパーキューブ上の巡回路
- **対称群**: ビット反転の対称性群との関連
- **グラフ理論**: 各ビットパターンを頂点とするグラフ構造

---

## 💡 活用例

### 実用的応用

#### セキュリティ・暗号分野
- **サイドチャネル攻撃対策**：スマートカードや暗号チップでの電力消費パターン隠蔽
  - グレイコードの1ビット変化特性により、隣接値間での電力消費変化を最小化
  - 電力解析攻撃（Power Analysis Attack）やタイミング攻撃への耐性向上
  - ハミング重み（ビット中の1の個数）変化の最小化による攻撃防御
- **暗号実装のセキュリティ**：暗号プロセッサでの中間値漏洩対策
  - 状態遷移時の電磁波放射パターンの一様化
  - フォルトインジェクション攻撃に対する堅牢性向上
- **セキュアエンコーダー**：セキュリティシステムでの位置・状態検出
  - 物理セキュリティシステムでの改竄検出
  - アクセス制御システムでの確実な状態判定

#### 通信・エラー制御分野
- **SDR／通信学習**：雑音がある状況での誤復調時、Gray vs Binary ラベリングの違いを体感し、BER（ビット誤り率）差への直感を養う
- **エラー検出・訂正**：ノイズ環境下でのデータ伝送の信頼性向上
- **QAM変調システム**：隣接シンボル間のハミング距離を1に保つことで誤り訂正効率を向上

#### 産業・制御分野
- **絶対型エンコーダー**：工作機械やロボットアームの正確な位置検出
- **状態遷移制御**：PLCや組み込みシステムでの安定した状態管理

#### 教育・研究分野
- **アルゴリズム学習**：ハミルトン路問題、組合せ最適化の教材
- **CTF問題設計**：隣接1ビット差遷移を利用したパズル問題
- **プログラミング課題**：ビット操作とアルゴリズムの理解促進

### 通信／ネットワーク
16-QAM などで Gray ラベリングを使うことで、隣接シンボル誤り時のビット誤り数を最小限に抑える。

### 絶対型ロータリーエンコーダー
位置センサーに Gray コードを用いることで、回転角度の変化中の誤読を抑制できる。
**数学的根拠**: 角度変化時の複数ビット同時変化を防ぎ、測定誤差を最小化。

### 論理最適化（カルノー図）
カルノー図の見出しを Gray 順にすることで、隣接セルを容易にグループ化し、論理最適化を簡便にする。
**理論的背景**: ハミルトン路の性質により、隣接関係が保たれたグルーピングが可能。

### 画像圧縮・ゲーム解法
- **画像処理**: ピクセル値の段階的変化における誤差拡散制御
- **パズル解法**: 状態空間探索での効率的な経路生成
- **アルゴリズム設計**: 組合せ最適化問題での解空間探索
- **CTF競技者**: ビット操作パズル問題

---

## 📁 ディレクトリー構成

```
GrayNinja/
├── index.html        # メインページ
├── script.js         # 全機能のJavaScript
├── style.css         # スタイルシート
├── README.md         # このファイル
├── LICENSE           # ライセンス
├── CLAUDE.md         # Claude Code設定ファイル
├── .gitignore        # Git除外設定
├── .nojekyll         # GitHub Pages設定
└── assets/           # アセットディレクトリー
    └── screenshot.png # スクリーンショット画像
```

---

## 🔒 セキュリティ対策

本ツールはGitHub Pages上での安全な公開を目的として、以下のセキュリティ対策を実装しています：

### クライアントサイドセキュリティ

#### XSS (Cross-Site Scripting) 対策
- **DOM操作の安全化**: `innerHTML`の使用を避け、`textContent`と`createElement`による安全なDOM構築
- **入力値のサニタイゼーション**: ユーザー入力の厳格な検証とフィルタリング
- **出力エスケープ**: 動的コンテンツの安全な表示

#### Content Security Policy (CSP)
```html
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' 'unsafe-inline';
  style-src 'self' 'unsafe-inline';
  img-src 'self' data:;
  font-src 'self';
  connect-src 'none';
  object-src 'none';
  base-uri 'self';
  form-action 'none';
">
```

#### 入力検証とサニタイゼーション
- **数値入力の境界値チェック**: ビット数（1-12）、値の範囲制限
- **文字列入力のフィルタリング**: バイナリコード入力での0/1のみ許可
- **DoS攻撃対策**: 異常に大きな値や長い文字列の拒否
- **型チェック**: 期待されるデータ型の厳格な検証

#### ローカルストレージのセキュリティ
- **値の検証**: 保存・読み込み時の期待値チェック（'light'/'dark'のみ）
- **エラーハンドリング**: localStorage使用不可時の適切な処理
- **機能継続性**: ストレージエラー時でも基本機能の維持

#### エラーハンドリング
- **例外処理**: try-catchによる適切なエラー処理
- **ログ出力**: 開発者向けの警告・エラーログ
- **フォールバック**: エラー時の安全な代替動作

### 実装上の安全性

#### 静的解析対応
- **型安全性**: JavaScript関数の型チェック強化
- **境界値処理**: 配列アクセスやビット演算の安全性確保
- **メモリ安全性**: 大量データ処理時のメモリリーク防止

#### パフォーマンスセキュリティ
- **DoS攻撃対策**: 計算量制限、入力サイズ制限
- **リソース保護**: CPUとメモリの過度な使用防止
- **レスポンシブ設計**: UI応答性の維持

これらの対策により、GitHub Pagesでの安全で信頼性の高い運用を実現しています。

---

## 📄 ライセンス

MIT License – 詳細は [LICENSE](LICENSE) を参照してください。

---

## 🛠 このツールについて

本ツールは、「生成AIで作るセキュリティツール100」プロジェクトの一環として開発されました。
このプロジェクトでは、AIの支援を活用しながら、セキュリティに関連するさまざまなツールを100日間にわたり制作・公開していく取り組みを行っています。

プロジェクトの詳細や他のツールについては、以下のページをご覧ください。

🔗 [https://akademeia.info/?page_id=42163](https://akademeia.info/?page_id=42163)
